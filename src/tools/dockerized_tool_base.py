import abc
import logging
import os
import time
import uuid

import docker

from api.schemas.user_file import UserFileDto
from conf.const import ROOT_DIR
from services.file_storage_service import FileStorageService

logger = logging.getLogger(__name__)


class DockerizedToolBase(abc.ABC):
    """
    Base class for dockerized tools which provides
    a framework for running tools in Docker containers.

    Override the following attributes:
        - image_name: Name of the Docker image.
        - cmd_params: Command parameters for the program run inside the container.
        - docker_run_kwargs: Specification of arguments for the Docker container runtime.
                             Useful for setting environment variables, volumes, etc.

    Overriding any of the following methods is optional, but encouraged:
        - _get_cmd_params: Customize command parameters for the Docker container.
        - _get_docker_run_kwargs: Customize arguments for the Docker container runtime.
        - _preprocess: Preprocess input files before running the Docker container.
        - _postprocess: Postprocess the output of the Docker container.
        - _get_output_files: Get the output files generated by the Docker container.
        - _get_error: Customize the error message from the Docker container.

    The run() template method orchestrates the entire tool runtime process.
    It is not supposed to be overridden.
    """

    image_name = None
    cmd_params = None
    docker_run_kwargs = {}

    def __init__(self, file_storage_service: FileStorageService, docker: docker.DockerClient):
        self._file_storage_service = file_storage_service
        self._docker = docker

        if self.image_name is None:
            raise ValueError(f'image_name must be set in "{self.__class__.__name__}"')

    def _get_cmd_params(self, **_) -> str:
        """
        Get command parameters for the docker container.

        Args:
            **kwargs: Input data for the tool.
        Returns:
            str: Command parameters for the docker container.
        Raises:
            ValueError: If cmd_params is not set.
        """
        if self.cmd_params is None:
            raise ValueError(f'cmd_params must be set in "{self.__class__.__name__}"')

        return self.cmd_params

    def _get_docker_run_kwargs(self, **_) -> dict:
        """
        Get arguments for the docker container runtime.

        Args:
            **kwargs: Input data for the tool.
        Returns:
            dict: Docker run kwargs.
        """
        return self.docker_run_kwargs

    async def _preprocess(self, *, _token: uuid.UUID, _input_files: list[str], **_) -> None:
        """
        Preprocess the input files before running the dockerized tool.

        Args:
            token (str): Unique identifier for the calculation.
            input_files (list[str]): List of input files to be processed.
            **kwargs: Input data for the tool.
        Raises:
            ValueError: If neither input_file nor input_files is provided.
        """
        if not _input_files:
            raise ValueError("Either input_file or input_files must be provided")

        os.makedirs(ROOT_DIR / f"data/docker/{self.image_name}/{_token}/in", exist_ok=True)
        await self._file_storage_service.download_files(
            _input_files, ROOT_DIR / f"data/docker/{self.image_name}/{_token}/in"
        )

    async def _postprocess(self, *, _output: str, **_) -> tuple[dict, list[str]]:
        """
        Postprocess the output of the dockerized tool.
        By default, it uploads the output files to the file storage.

        Args:
            _output (str): The output string from the tool.
            token (uuid.UUID): Unique identifier for the calculation.
            **kwargs: Input data for the tool.
        Returns:
            str: The processed output string.

        """
        return {"result": _output}, []

    async def _send_files(self, *, token: uuid.UUID, file_names: str) -> list[UserFileDto]:
        return [
            file
            async for file in self._file_storage_service.upload_files(
                file_names, ROOT_DIR / f"data/docker/{self.image_name}/{token}/out"
            )
        ]

    def _get_error(self, msg: str) -> str:
        """
        Get the error message from the dockerized tool.

        Args:
            msg (str): The error message from the tool.
        Returns:
            str: The formatted error message.
        """
        return f"Tool {self.image_name} failed: {msg}"

    async def run(self, **kwargs) -> tuple[str, list[str]]:
        """
        Run the dockerized tool with the provided parameters.

        Args:
            **kwargs: Keyword arguments to be passed to the tool.
                - token: Unique identifier for the calculation.
                - input_files: List of input files to be processed.
                - user_id: Identifier of the user running the tool.
                - **kwargs: Input data for the tool.
        Returns:
            tuple: A tuple containing the processed output and a list of output files.
                - postprocessed_result: Processed output from the tool.
                - output_files: List of output files generated by the tool.
        Raises:
            ContainerRuntimeError: If the docker container runtime fails.
            RuntimeError: If an error occurs during postprocessing.
        """
        logger.debug(f"Running {self.image_name} tool with kwargs={kwargs}")
        start_time = time.time()

        logger.debug("Invoking preprocess")
        await self._preprocess(**kwargs)

        logger.debug("Obtaining cmd_params")
        cmd_params = self._get_cmd_params(**kwargs)
        logger.debug(f"Obtained cmd_params: {cmd_params}")

        try:
            logger.debug(f"Running docker container: {self.image_name} {cmd_params}")
            calculation_result = self._docker.containers.run(
                self.image_name,
                cmd_params,
                **self._get_docker_run_kwargs(**kwargs),
            )
        except docker.errors.ContainerError as e:
            logger.error(f"Docker run failed on error: {e}")
            raise RuntimeError(self._get_error(e.stderr.decode("utf-8")))

        try:
            logger.debug("Docker run finished. Invoking postprocess")
            postprocessed_result, output_files = await self._postprocess(_output=calculation_result.decode(), **kwargs)
        except Exception as e:
            logger.exception(f"Postprocess error: {e}")
            raise RuntimeError("An error occurred during postprocessing. Please contact the administrator")

        time_total = time.time() - start_time
        logger.info(f"Tool {self.image_name} finished successfully in {time_total:.2f} seconds")
        return postprocessed_result, output_files
